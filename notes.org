* Removing hooks
  Let's say I added a lambda function that is giving errors
  #+BEGIN_SRC emacs-lisp

(add-hook 'clojure-mode-hook
	  (lambda ()
	    (message "how do i remove myself??")))


clojure-mode-hook
(first clojure-mode-hook)

(remove-hook 'clojure-mode-hook (first clojure-mode-hook))
  #+END_SRC
* profiling time of each block
  + https://emacs.stackexchange.com/a/21251/19673

  #+BEGIN_SRC emacs-lisp
(defmacro with-timer (title &rest forms)
  "Run the given FORMS, counting the elapsed time.
A message including the given TITLE and the corresponding elapsed
time is displayed."
  (declare (indent 1))
  (let ((nowvar (make-symbol "now"))
        (body   `(progn ,@forms)))
    `(let ((,nowvar (current-time)))
       (message "%s..." ,title)
       (prog1 ,body
         (let ((elapsed
                (float-time (time-subtract (current-time) ,nowvar))))
           (message "%s... done (%.3fs)" ,title elapsed))))))



  #+END_SRC
** COMMENT playing with use-package
   #+BEGIN_SRC emacs-lisp

(defalias 'use-package-old 'use-package)
(defmacro use-package (&rest forms)
  (declare (indent 1))
  (let ((nowvar (make-symbol "now"))
        (body   `(progn (use-package-old ,@forms)))
	(package (symbol-name (first forms)))
	)
    `(let ((,nowvar (current-time)))
       (message "use-package: %s..." ,package)
       (prog1 ,body
         (let ((elapsed
                (float-time (time-subtract (current-time) ,nowvar))))
           (message "%s... done (%.3fs)" ,package elapsed))))))

(macroexpand-all '(use-package-old helm))
(macroexpand-1 '(use-package2 helm))
(use-package helm)
(macroexpand-all '(with-timer "test " (+ 1 2)))
   #+END_SRC
* Highlighting thing under cursor etc..
  + M-x highlight-symbol-at-point
    or add C-u prefix to select what color shall be used
  + M-x unhighlight-regexp
    to remove highlights.. gives you a list of what is already highlighted. nice!
* listing edited buffers
  see https://www.reddit.com/r/emacs/comments/6w1kqi/listing_unsaved_buffers/dm4sizy/
  + run =ibuffer=
  + run =ibuffer-filter-by-modified=
    would be nice here to only show actual files (and no \*minibuffer\* etc)
* TODO about emacs 27.1
  + tab bar (per window and per frame)
    https://www.emacswiki.org/emacs/TabBarMode
    could add button in specific buffers (per window) for certain actions?
    eg
    + in cider : addbutton for clear cider buffer
  + so-long
    https://www.emacswiki.org/emacs/SoLong
    optimization for long lines bringing emacs to its knees
* Spelling
** Windows setup
* ober eval in repl & vars
  :PROPERTIES:
  :header-args: :session *test* :var test="abc" test2="def" :dir ~/dev
  :END:

  #+BEGIN_SRC sh :dir ~/dev
pwd
  #+END_SRC

  #+RESULTS:
  |                        |
  | $ $ /home/actondev/dev |

  The problem is that upon initializing the session, $test is not defined

  This is how we can get the assignments
  #+BEGIN_SRC emacs-lisp

(org-babel-expand-body:generic
 nil
 nil
 (org-babel-variable-assignments:shell (nth 2 (org-babel-get-src-block-info))))

(org-babel-variable-assignments:shell (nth 2 (org-babel-get-src-block-info)))
  #+END_SRC


** dir
   [[file:/usr/share/emacs/26.3/lisp/org/ob-core.el.gz::(default-directory]]
   in org-babel-execute-src-block

* Header args
  https://orgmode.org/manual/Using-Header-Arguments.html

  For a subheading add
  #+BEGIN_EXAMPLE
    :PROPERTIES:
  :header-args: :session *test* :var test="abc" test2="def" :dir ~/dev
  :END:
  #+END_EXAMPLE

  for all the document

  #+BEGIN_EXAMPLE
#+PROPERTY: header-args:R  :session *R*
  #+END_EXAMPLE

  results:
  - silent
  - replace (default)
* Advices (example for org-babel-get-serc-block-info)
  For my work on https://github.com/diadochos/org-babel-eval-in-repl/issues/31
  #+BEGIN_SRC emacs-lisp
(defun aod.org/src-info-light ()
  "Returns the src-block-info without evaluating anything.
   While passing 'light to org-babel-get-src-block-info makes the
   :var definitions not evaluate any lisp expressions, other
   things (like :dir for example) get evaluated.

   For example, the following org src header would cause the
   elisp to be evaluated everytime upon calling
   org-babel-get-src-block-info

   :dir (read-directory-name \"dir name:\")"
  (cl-flet ((read-advice (read-orig in &rest _)
			 (funcall read-orig in 'inhibit-lisp-eval)))
    (advice-add 'org-babel-read :around #'read-advice)
    (let ((info (org-babel-get-src-block-info 'light)))
      (advice-remove 'org-babel-read #'read-advice)
      info)))  
  #+END_SRC
* Profiling startup time
  https://blog.d46.us/advanced-emacs-startup/
  #+BEGIN_SRC emacs-lisp
(use-package esup
  :ensure t
  ;; To use MELPA Stable use ":pin mepla-stable",
  :pin melpa
  :commands (esup))
  #+END_SRC

* windows: bash & cmd - enter once in cmd
  #+BEGIN_SRC sh
[[ -z "$home" ]] && cmd
  #+END_SRC

* Local variables - running code on open
  for example, in an org-mode file I had
  #+BEGIN_EXAMPLE org

# Local Variables:
# eval: (aod.org-babel/eval-named-block "buttons")
# eval: (org-babel-goto-named-result "buttons")
# End:

  #+END_EXAMPLE

  the =(org-babel-goto-named-result "buttons")= though doesn't work.
  Upon opening the file the cursor is at the beginning
* Editing example src code
  org-edit-src-code
  #+BEGIN_SRC elisp
(let ((lang
       (if (eq type 'src-block) (org-element-property :language (org-element-at-point))
	 "example"))
      ;; ...
      )
  #+END_SRC

  #+BEGIN_SRC c
printf("hi");
  #+END_SRC

  =(org-element-at-point)= gives
  #+BEGIN_SRC elisp
(src-block (:language "c" :switches nil :parameters nil :begin 3682 :end 4317 :number-lines nil ...))  
  #+END_SRC

  #+BEGIN_EXAMPLE c
printf("hi");
  #+END_EXAMPLE

  gives

  #+BEGIN_SRC elisp
(example-block (:begin 5614 :end 5663 :value "printf(\"hi\");
" :switches "c" :number-lines nil :preserve-indent nil ...))
  #+END_SRC
* org babel notes
  disable confirming:
  =org-confirm-babel-evaluate=
  (setq-local to set on certain buffer)
  - org-babel-use-quick-and-dirty-noweb-expansion
    ??
** noweb, templating etc

   #+NAME: c-template
   #+BEGIN_SRC c :noweb yes
printf("hi, A is {A} and B is {B}");
   #+END_SRC

   #+NAME: c-template2
   #+BEGIN_SRC c :noweb yes
printf("hi, A is {A} and B is {B}");
<<render2(a="another a",b="another b")>>
   #+END_SRC

   #+NAME: render
   #+BEGIN_SRC emacs-lisp :var template="c-template" a="value_a" b="value_b" :wrap SRC cpp
(-as-> (aod.org/src-block-content template) x
       (replace-regexp-in-string (regexp-quote "{A}") a x t)
       (replace-regexp-in-string (regexp-quote "{B}") b x t)
       )
   #+END_SRC

   #+RESULTS: render
   #+BEGIN_SRC cpp
printf("hi, A is value_a and B is value_b");
   #+END_SRC


   This cause an infinite recursion!
   #+NAME: render2
   #+BEGIN_SRC emacs-lisp :var template="c-template2" a="value_a" b="value_b" :wrap SRC cpp
(-as-> (aod.org/src-block-content-noweb template) x
       (replace-regexp-in-string (regexp-quote "{A}") a x t)
       (replace-regexp-in-string (regexp-quote "{B}") b x t)
       )
   #+END_SRC


*** nested.. example
    #+NAME: expand
    #+BEGIN_SRC emacs-lisp :var template="the-template" c-type="bool"
(-as-> (aod.org/src-block-content-noweb template) x
       (replace-regexp-in-string "C_TYPE" c-type x t)
       )
    #+END_SRC

    #+NAME: T-struct
    #+BEGIN_SRC c
typedef struct {
     size_t size;
     C_TYPE* elements;
} C_TYPE_arr;
    #+END_SRC

    #+NAME: T-struct+
    #+BEGIN_SRC c :noweb yes
// here we see the struct for C_TYPE
<<T-struct>>
    #+END_SRC

    #+NAME: render-structs
    #+BEGIN_SRC emacs-lisp :wrap src c
(mapconcat
 (lambda (type)
   (-as-> (aod.org/src-block-content-noweb "T-struct+") x
	  (replace-regexp-in-string "C_TYPE" type x t)
	  ))
 (list "bool" "int" "float")
 "\n\n")
    #+END_SRC


    #+BEGIN_SRC c :noweb yes
// and.. fuclly expanded here

<<render-structs()>>

  // we did it!
  // run org-babel-expand-src-block to see the result


    #+END_SRC

    gives
    #+BEGIN_EXAMPLE c
// and.. fuclly expanded here

// here we see the struct for bool
typedef struct {
     size_t size;
     bool* elements;
} bool_arr;

// here we see the struct for int
typedef struct {
     size_t size;
     int* elements;
} int_arr;

// here we see the struct for float
typedef struct {
     size_t size;
     float* elements;
} float_arr;

  // we did it!
  // run org-babel-expand-src-block to see the result

    
    #+END_EXAMPLE
** header flags
   - :main no
     in C blocks
   - :noweb-ref foo
     instead of naming the blocks..? it's an option
